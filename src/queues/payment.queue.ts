// src/queues/payment.queue.ts
import { Queue, Worker } from 'bullmq';
import { logger } from '../utils/logger';
import NotificationService from '../services/notification.service';
import { INotification } from '../models/notification.model';
import TransactionService from '../services/transaction.service';
import AlatPayService from '../services/payment/alatpay.service';
import { TransactionStatus } from '../models/transaction.model';
import { connection } from './connection';
import ShoppingListService from '../services/shoppingList.service';
import OrderService from '../services/order.service';

// Define job data interface
interface PaymentWebhookJobData {
    providerTransactionId: string;
    transactionId: string;
    userId: string;
}

interface PaymentExpiryCheckJobData {
    transactionId: string;
    userId: string;
}

// Create queues
export const paymentWebhookQueue = new Queue<PaymentWebhookJobData>('payment-webhook', {
    connection: {
        host: process.env.REDIS_HOST || 'localhost',
        port: parseInt(process.env.REDIS_PORT || '6379'),
    },
});

export const paymentExpiryCheckQueue = new Queue<PaymentExpiryCheckJobData>(
    'payment-expiry-check',
    { connection },
);

// Process webhook jobs
const webhookWorker = new Worker<PaymentWebhookJobData>(
    'payment-webhook',
    async job => {
        if (job.name !== 'process-webhook') {
            throw new Error(`Unknown job name: ${job.name}`);
        }

        const { providerTransactionId, transactionId } = job.data;
        logger.info(`Processing payment webhook for transaction ${transactionId}`);

        try {
            // Get transaction status from AlatPay
            const { data: transactionStatus } =
                await AlatPayService.checkTransactionStatus(providerTransactionId);

            // Map AlatPay status to our TransactionStatus enum
            const mappedStatus = AlatPayService.mapAlatPayStatusToLocal(transactionStatus.status);

            // Update transaction status
            const transaction = await TransactionService.updateTransactionStatus(transactionId, mappedStatus);

            // If payment is successful and it's for a shopping list, update the shopping list status and create order
            if (mappedStatus === TransactionStatus.COMPLETED && transaction.type === 'shopping_list') {
                try {
                    // Update shopping list status to 'accepted'
                    await ShoppingListService.updateListStatus(
                        transaction.referenceId,
                        transaction.userId,
                        'accepted'
                    );
                    
                    logger.info(`Shopping list ${transaction.referenceId} status updated to accepted`);
                    
                    // Get payment details from session or database to get delivery address
                    // For now, create order with basic details - delivery address should be updated via API
                    const order = await OrderService.createOrder({
                        customerId: transaction.userId,
                        shoppingListId: transaction.referenceId,
                        totalAmount: transaction.amount,
                        status: 'pending',
                        paymentStatus: 'completed',
                        paymentId: transaction.id,
                        paymentProcessedAt: new Date(),
                        serviceFee: Math.round(transaction.amount * 0.05), // 5% service fee
                        deliveryFee: 500, // Default delivery fee in Naira
                        deliveryAddress: {
                            latitude: 6.5244, // Default Lagos coordinates
                            longitude: 3.3792,
                            address: 'Customer delivery address',
                            city: 'Lagos',
                            state: 'Lagos',
                            country: 'Nigeria',
                            additionalDirections: 'Address to be confirmed by customer'
                        }
                    });
                    
                    logger.info(`Order ${order.id} created for shopping list ${transaction.referenceId}`);
                } catch (error) {
                    logger.error('Error updating shopping list status or creating order:', error);
                    // Don't throw here to avoid retrying the entire webhook
                }
            }

            // Send notification
            const notification: INotification = {
                id: '', // Will be generated by the database
                userId: job.data.userId,
                title: 'Payment Status Update',
                message: mappedStatus === TransactionStatus.COMPLETED 
                    ? 'Your payment has been confirmed successfully!'
                    : `Your payment has been ${mappedStatus}`,
                heading: 'Payment Update',
                read: false,
                resource: transactionId,
            };
            await NotificationService.addNotification(notification);

            return { success: true };
        } catch (error) {
            logger.error('Error processing payment webhook:', error);
            throw error;
        }
    },
    { connection },
);

// Process expiry check jobs
const expiryCheckWorker = new Worker<PaymentExpiryCheckJobData>(
    'payment-expiry-check',
    async job => {
        if (job.name !== 'check-expiry') {
            throw new Error(`Unknown job name: ${job.name}`);
        }

        const { transactionId } = job.data;
        logger.info(`Checking payment expiry for transaction ${transactionId}`);

        try {
            // Update transaction status to failed
            await TransactionService.updateTransactionStatus(transactionId, TransactionStatus.FAILED);

            // Send notification
            const notification: INotification = {
                id: '', // Will be generated by the database
                userId: job.data.userId,
                title: 'Payment Expired',
                message: 'Your payment has expired. Please try again.',
                heading: 'Payment Expired',
                read: false,
                resource: transactionId,
            };
            await NotificationService.addNotification(notification);

            return { success: true };
        } catch (error) {
            logger.error('Error checking payment expiry:', error);
            throw error;
        }
    },
    { connection },
);

// Error handling
webhookWorker.on('error', (error: Error) => {
    logger.error('Payment webhook worker error:', error);
});

webhookWorker.on('failed', (job: any, error: Error) => {
    logger.error(`Job ${job?.id} failed:`, error);
});

expiryCheckWorker.on('error', (error: Error) => {
    logger.error('Payment expiry check worker error:', error);
});

expiryCheckWorker.on('failed', (job: any, error: Error) => {
    logger.error(`Job ${job?.id} failed:`, error);
});
